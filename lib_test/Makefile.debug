# Makefile to build and run the test files in a variety of ways

BUILDINC := -I ../ sql_access.cma
P4INC := -I$(shell ocamlfind query type-conv) -I$(shell ocamlfind query sqlite3) -I ../

TESTS := alltypes foreign_and_variant list_foreign list_simple nested_tuple simple_option \
	tuple variant_tuple simple_alltypes \
	array_simple foreign_nested list_list list_tuple recursive simple_twodefs variant \
	foreign foreign_tuple list_recursive nested_option simple variant_nested 
#	delete

PACKS= -package unix,sqlite3,oUnit

.PHONY: all
all: $(TESTS:%=pr_%) $(TESTS:%=r_%) $(TESTS:%=pi_%) $(TESTS:%=i_%)
	@ :

../pa_sql_orm.cma: ../pa_sql_orm.ml ../sql_types.ml
	cd .. && $(MAKE) -f Makefile.camlp4 clean pa_sql_orm.cma

# p_% prints out the process ML file to stdout
.PHONY: p_%
p_%: ../pa_sql_orm.cma
	camlp4orf $(P4INC) pa_type_conv.cmo -parser ../pa_sql_orm.cma -printer o $*.ml

# top_% makes a top-level for the ML file
top_%: pc_%
	ocamlfind ocamlmktop $(PACKS) -linkpkg -o $@ -I ../ sql_access.cma pc_$*.cmo

# pc_% compiles it via a temporary ML file (pc_%.ml) so that locations in generated code can be
# seen in error messages as a debugging aid
pc_%: %.ml ../pa_sql_orm.cma
	camlp4orf $(P4INC) pa_type_conv.cmo -parser pa_sql_orm.cma -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -linkpkg -g -annot -o $@ $(PACKS) $(BUILDINC) $@.ml

# pr_% compiles and runs the code via the intermediate ML file
pr_%: pc_%
	@./$<

# c_% compiles the ML file directly by invoking camlp4 as -pp (how it is used in production)
c_%: %.ml ../pa_sql_orm.cma
	ocamlfind ocamlc -verbose -o $@ -linkpkg -g $(PACKS) \
	  -pp "camlp4orf $(P4INC) pa_type_conv.cmo pa_sql_orm.cma " \
	  $(BUILDINC) $*.ml

nc_%: %.ml
	ocamlfind ocamlopt -o $@ -linkpkg $(PACKS) \
	  -pp "camlp4orf $(P4INC) pa_type_conv.cmo pa_sql_orm.cma " \
	  -I ../ sql_access.cmx $*.ml

# r_% runs the executable generated by directly compiling with the p4 extension
r_%: c_%
	@./$<

# i_% displays the inferred OCaml interface of the generated functions
.PHONY: i_%
i_%: %.ml ../pa_sql_orm.cma
	ocamlfind ocamlc -i -verbose -linkpkg -g $(PACKS) \
	  -pp "camlp4orf $(P4INC) pa_type_conv.cmo pa_sql_orm.cma" $(BUILDINC) $*.ml

# pi_% prints to a temporary file and then displays the Ocaml interface
pi_%: %.ml ../pa_sql_orm.cma
	camlp4orf $(P4INC) pa_type_conv.cmo -parser pa_sql_orm.cma -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -i -linkpkg -g $(PACKS) $(BUILDINC) $@.ml
	
.PHONY: clean
clean:
	rm -f pc_* c_* pi_* *.cmo *.cma *.db *.cmi top_*
