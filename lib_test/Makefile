# Makefile to build and run the test files in a variety of ways

BUILDINC := -I ../
P4INC := -I$(shell ocamlc -where)/site-lib/type-conv -I$(shell ocamlc -where)/site-lib/sqlite3 $(BUILDINC)

TESTS := simple tuple foreign variant

.PHONY: all
all: $(TESTS:%=pr_%) $(TESTS:%=r_%) $(TESTS:%=i_%)
	@ :

../pa_sql_orm.cma: ../pa_sql_orm.ml ../sql_types.ml
	cd .. && $(MAKE) -f Makefile.camlp4 clean pa_sql_orm.cma

# p_% prints out the process ML file to stdout
.PHONY: p_%
p_%: ../pa_sql_orm.cma
	camlp4orf $(P4INC) pa_type_conv.cmo sqlite3.cma -parser ../pa_sql_orm.cma -printer o $*.ml

# pc_% compiles it via a temporary ML file (pc_%.ml) so that locations in generated code can be
# seen in error messages as a debugging aid
pc_%: %.ml ../pa_sql_orm.cma
	camlp4orf $(P4INC) pa_type_conv.cmo sqlite3.cma -parser pa_sql_orm.cma -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -o $@ -custom -package unix,sqlite3 -I .. unix.cma sqlite3.cma sql_access.cma $@.ml

# pr_% compiles and runs the code via the intermediate ML file
pr_%: pc_%
	@./$<

# c_% compiles the ML file directly by invoking camlp4 as -pp (how it is used in production)
c_%: %.ml ../pa_sql_orm.cma
	ocamlfind ocamlc -verbose -o $@ -custom -package unix,sqlite3 \
	  -pp "camlp4orf $(P4INC) pa_type_conv.cmo sqlite3.cma pa_sql_orm.cma " \
	  $(BUILDINC) unix.cma sqlite3.cma sql_access.cma $*.ml

# r_% runs the executable generated by directly compiling with the p4 extension
r_%: c_%
	@./$<

# i_% displays the inferred OCaml interface of the generated functions
.PHONY: i_%
i_%: %.ml ../pa_sql_orm.cma
	ocamlfind ocamlc -i -verbose -custom -package unix,sqlite3 \
	  -pp "camlp4orf $(P4INC) pa_type_conv.cmo sqlite3.cma pa_sql_orm.cma" \
	  $(BUILDINC) unix.cma sqlite3.cma sql_access.cma $*.ml

.PHONY: clean
clean:
	rm -f pc_* c_* *.cmo *.cma *.db *.cmi
