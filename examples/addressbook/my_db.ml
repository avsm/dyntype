(* autogenerated by sql_orm *)
open Printf
module Sql_access = struct
  (*
   * Copyright (c) 2009 Anil Madhavapeddy <anil@recoil.org>
   *
   * Permission to use, copy, modify, and distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *)
  
  open Sqlite3
  open Printf
  
  type transaction_mode = [
      |`Deferred
      |`Immediate
      |`Exclusive
  ]
  
  type state = {
      db : db;
      mutable in_transaction: int;
      busyfn: db -> unit;
      mode: transaction_mode;
  }
  
  let default_busyfn (db:Sqlite3.db) =
      print_endline "WARNING: busy";
      Thread.delay (Random.float 1.)
  
  let raise_sql_error x =
      raise (Sqlite3.Error (Rc.to_string x))
  
  let try_finally fn finalfn =
      try
        let r = fn () in
        finalfn ();
        r
      with e -> begin
        print_endline (sprintf "WARNING: exception: %s" (Printexc.to_string e));
        finalfn ();
        raise e
      end
  
  (* retry until a non-BUSY error code is returned *)
  let rec db_busy_retry db fn =
      match fn () with
      |Rc.BUSY -> 
         db.busyfn db.db;
         db_busy_retry db fn;
      |x -> x
  
  (* make sure an OK is returned from the database *)
  let db_must_ok db fn =
      match db_busy_retry db fn with
      |Rc.OK -> ()
      |x -> raise_sql_error x
  
  (* make sure a DONE is returned from the database *)
  let db_must_done db fn = 
     match db_busy_retry db fn with
     |Rc.DONE -> ()
     |x -> raise_sql_error x
  
  (* request a transaction *)
  let transaction db fn =
      let m = match db.mode with
      |`Deferred -> "DEFERRED" |`Immediate -> "IMMEDIATE" |`Exclusive -> "EXCLUSIVE" in
      try_finally (fun () ->
          if db.in_transaction = 0 then (
             db_must_ok db (fun () -> exec db.db (sprintf "BEGIN %s TRANSACTION" m));
          );
          db.in_transaction <- db.in_transaction + 1;
          fn ();
      ) (fun () ->
          if db.in_transaction = 1 then (
             db_must_ok db (fun () -> exec db.db "END TRANSACTION");
          );
          db.in_transaction <- db.in_transaction - 1
      )
  
  (* iterate over a result set *)
  let step_fold db stmt iterfn =
      let stepfn () = Sqlite3.step stmt in
      let rec fn a = match db_busy_retry db stepfn with
      |Sqlite3.Rc.ROW -> fn (iterfn stmt :: a)
      |Sqlite3.Rc.DONE -> a
      |x -> raise_sql_error x
      in
      fn []
end


open Sql_access
module Person = struct
  type t = <
    id : int64 option;
    set_id : int64 option -> unit;
    name : string;
    set_name : string -> unit;
    age : int64 option;
    set_age : int64 option -> unit;
    email : string;
    set_email : string -> unit;
    save: int64; delete: unit
  >

  let init db =
    let sql = "create table if not exists person (id integer primary key autoincrement,name text,age integer,email text);" in
    db_must_ok db (fun () -> Sqlite3.exec db.db sql);
    ()

  (* object definition *)
  let t ?(id=None) ~name ?(age=None) ~email db : t = object
    (* get functions *)
    val mutable _id = id
    method id : int64 option = _id
    val mutable _name = name
    method name : string = _name
    val mutable _age = age
    method age : int64 option = _age
    val mutable _email = email
    method email : string = _email

    (* set functions *)
    method set_id v =
      _id <- v
    method set_name v =
      _name <- v
    method set_age v =
      _age <- v
    method set_email v =
      _email <- v

    (* admin functions *)
    method delete =
      match _id with
      |None -> ()
      |Some id ->
        print_endline ("person.delete: id found, deleting");
        let sql = "DELETE FROM person WHERE id=?" in
        print_endline ("person.delete: " ^ sql);
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (Sqlite3.Data.INT id));
        ignore(step_fold db stmt (fun _ -> ()));
        _id <- None

    method save = transaction db (fun () ->
      (* insert any foreign-one fields into their table and get id *)
      let _curobj_id = match _id with
      |None -> (* insert new record *)
        print_endline ("person.save: inserting new record");
        let sql = "INSERT INTO person VALUES(NULL,?,?,?)" in
        print_endline ("person.save: " ^ sql);
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _name in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (match _age with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _email in Sqlite3.Data.TEXT v));
        db_must_done db (fun () -> Sqlite3.step stmt);
        let __id = Sqlite3.last_insert_rowid db.db in
        _id <- Some __id;
        __id
      |Some id -> (* update *)
        print_endline (sprintf "person.save: id %Lu exists, updating" id);
        let sql = "UPDATE person SET name=?,age=?,email=? WHERE id=?" in
        print_endline ("person.save: " ^ sql);
        let stmt = Sqlite3.prepare db.db sql in
        db_must_ok db (fun () -> Sqlite3.bind stmt 1 (let v = _name in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 2 (match _age with |None -> Sqlite3.Data.NULL |Some v -> Sqlite3.Data.INT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 3 (let v = _email in Sqlite3.Data.TEXT v));
        db_must_ok db (fun () -> Sqlite3.bind stmt 4 (Sqlite3.Data.INT id));
        db_must_done db (fun () -> Sqlite3.step stmt);
        id
      in
      _curobj_id
    )
  end

  (* General get function for any of the columns *)
  let get ?(id=None) ?(name=None) ?(age=None) ?(email=None) ?(custom_where=("",[])) db =
    (* assemble the SQL query string *)
    let q = "" in
    let _first = ref true in
    let f () = match !_first with |true -> _first := false; " WHERE " |false -> " AND " in
    let q = match id with |None -> q |Some b -> q ^ (f()) ^ "person.id=?" in
    let q = match name with |None -> q |Some b -> q ^ (f()) ^ "person.name=?" in
    let q = match age with |None -> q |Some b -> q ^ (f()) ^ "person.age=?" in
    let q = match email with |None -> q |Some b -> q ^ (f()) ^ "person.email=?" in
    let q = match custom_where with |"",_ -> q |w,_ -> q ^ (f()) ^ "(" ^ w ^ ")" in
    let sql="SELECT person.id, person.name, person.age, person.email FROM person " ^ q in
    print_endline ("person.get: " ^ sql);
    let stmt=Sqlite3.prepare db.db sql in
    (* bind the position variables to the statement *)
    let bindpos = ref 1 in
    ignore(match id with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      print_endline ("bind: " ^ (Sqlite3.Data.to_string (Sqlite3.Data.INT v)));
      incr bindpos
    );
    ignore(match name with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      print_endline ("bind: " ^ (Sqlite3.Data.to_string (Sqlite3.Data.TEXT v)));
      incr bindpos
    );
    ignore(match age with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.INT v));
      print_endline ("bind: " ^ (Sqlite3.Data.to_string (Sqlite3.Data.INT v)));
      incr bindpos
    );
    ignore(match email with |None -> () |Some v ->
      db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos (Sqlite3.Data.TEXT v));
      print_endline ("bind: " ^ (Sqlite3.Data.to_string (Sqlite3.Data.TEXT v)));
      incr bindpos
    );
    ignore(match custom_where with |_,[] -> () |_,eb ->
      List.iter (fun b ->
        db_must_ok db (fun () -> Sqlite3.bind stmt !bindpos b);
        print_endline ("bind: " ^ (Sqlite3.Data.to_string b));
        incr bindpos
      ) eb);
    (* convert statement into an ocaml object *)
    let of_stmt stmt =
    t
      (* native fields *)
      ~id:(
      (match Sqlite3.column stmt 0 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: person id")))
      )
      ~name:(
      (match Sqlite3.column stmt 1 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      ~age:(
      (match Sqlite3.column stmt 2 with
        |Sqlite3.Data.NULL -> None
        |x -> Some (match x with |Sqlite3.Data.INT i -> i |x -> (try Int64.of_string (Sqlite3.Data.to_string x) with _ -> failwith "error: person age")))
      )
      ~email:(
      (match Sqlite3.column stmt 3 with
        |Sqlite3.Data.NULL -> failwith "null of_stmt"
        |x -> Sqlite3.Data.to_string x)
      )
      (* foreign fields *)
    db
    in 
    (* execute the SQL query *)
    step_fold db stmt of_stmt

end

module Init = struct
  type t = state
  type transaction_mode = [`Exclusive |`Deferred |`Immediate ]
  let t ?(busyfn=default_busyfn) ?(mode=`Immediate) db_name =
    let db = {db=Sqlite3.db_open db_name; in_transaction=0; mode=mode; busyfn=busyfn } in
    Person.init db;
    db

  let db handle = handle.db
end

